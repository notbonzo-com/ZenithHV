#pragma once

#include <stddef.h>

namespace std {

enum memory_order {
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
};

template< typename T >
class atomic {
private:
    T value;

public:
    atomic() = default;
    constexpr atomic( T desired ) noexcept : value( desired ) {}

    T load( memory_order order = memory_order_seq_cst ) const noexcept {
        return __atomic_load_n( &value, order );
    }

    void store( T desired, memory_order order = memory_order_seq_cst ) noexcept {
        __atomic_store_n( &value, desired, order );
    }

    T exchange( T desired, memory_order order = memory_order_seq_cst ) noexcept {
        return __atomic_exchange_n( &value, desired, order );
    }

    bool compare_exchange_strong( T& expected, T desired, memory_order success = memory_order_seq_cst, memory_order failure = memory_order_seq_cst ) noexcept {
        return __atomic_compare_exchange_n( &value, &expected, desired, false, success, failure );
    }

    T fetch_add( T arg, memory_order order = memory_order_seq_cst ) noexcept {
        return __atomic_fetch_add( &value, arg, order );
    }

    T fetch_sub( T arg, memory_order order = memory_order_seq_cst ) noexcept {
        return __atomic_fetch_sub( &value, arg, order );
    }

    T fetch_and( T arg, memory_order order = memory_order_seq_cst ) noexcept {
        return __atomic_fetch_and( &value, arg, order );
    }

    T fetch_or( T arg, memory_order order = memory_order_seq_cst ) noexcept {
        return __atomic_fetch_or( &value, arg, order );
    }

    T fetch_xor( T arg, memory_order order = memory_order_seq_cst ) noexcept {
        return __atomic_fetch_xor( &value, arg, order );
    }

    bool is_lock_free() const noexcept {
        return __atomic_is_lock_free( sizeof( T ), &value );
    }
    
    T operator++() { return fetch_add( 1 ); }
    T operator--() { return fetch_sub( 1 ); }

    T operator*() const { return *value; }
    T* operator->() const { return value; }

    T* operator&() const { return &value; }
    T* get() const { return &value; }

    operator T() const { return value; }
    T* address() const { return &value; }

    T* get_ptr() const { return &value; }
    T* get_ptr() { return &value; }

    void reset( T desired ) { store( desired ); }

    atomic( const atomic& ) = delete;
    atomic& operator=( const atomic& ) = delete;
};

template< typename T >
class atomic< T* > {
private:
    T* value;

public:
    atomic() = default;
    constexpr atomic( T* desired ) noexcept : value( desired ) {}

    T* load( memory_order order = memory_order_seq_cst ) const noexcept {
        return __atomic_load_n( &value, order );
    }

    void store( T* desired, memory_order order = memory_order_seq_cst ) noexcept {
        __atomic_store_n( &value, desired, order );
    }

    T* exchange( T* desired, memory_order order = memory_order_seq_cst ) noexcept {
        return __atomic_exchange_n( &value, desired, order );
    }

    bool compare_exchange_strong( T*& expected, T* desired, memory_order success = memory_order_seq_cst, memory_order failure = memory_order_seq_cst ) noexcept {
        return __atomic_compare_exchange_n( &value, &expected, desired, false, success, failure );
    }

    T* fetch_add( ptrdiff_t arg, memory_order order = memory_order_seq_cst ) noexcept {
        return __atomic_fetch_add( &value, arg * sizeof( T ), order );
    }

    T* fetch_sub( ptrdiff_t arg, memory_order order = memory_order_seq_cst ) noexcept {
        return __atomic_fetch_sub( &value, arg * sizeof( T ), order );
    }

    bool is_lock_free() const noexcept {
        return __atomic_is_lock_free( sizeof( T* ), &value );
    }

    atomic( const atomic& ) = delete;
    atomic& operator=( const atomic& ) = delete;
};

class atomic_flag {
private:
    bool flag;

public:
    atomic_flag() noexcept : flag( false ) {}

    bool test_and_set( memory_order order = memory_order_seq_cst ) noexcept {
        return __atomic_test_and_set( &flag, order );
    }

    void clear( memory_order order = memory_order_seq_cst ) noexcept {
        __atomic_clear( &flag, order );
    }

    atomic_flag( const atomic_flag& ) = delete;
    atomic_flag& operator=( const atomic_flag& ) = delete;
};

template< typename T >
void atomic_store( atomic< T >* obj, T desired ) noexcept {
    obj->store( desired );
}

template< typename T >
T atomic_load( const atomic< T >* obj ) noexcept {
    return obj->load();
}

template< typename T >
T atomic_exchange( atomic< T >* obj, T desired ) noexcept {
    return obj->exchange( desired );
}

template< typename T >
bool atomic_compare_exchange_strong( atomic< T >* obj, T* expected, T desired ) noexcept {
    return obj->compare_exchange_strong( *expected, desired );
}

template< typename T >
T atomic_fetch_add( atomic< T >* obj, T arg ) noexcept {
    return obj->fetch_add( arg );
}

template< typename T >
T atomic_fetch_sub( atomic< T >* obj, T arg ) noexcept {
    return obj->fetch_sub( arg );
}

template< typename T >
T atomic_fetch_and( atomic< T >* obj, T arg ) noexcept {
    return obj->fetch_and( arg );
}

template< typename T >
T atomic_fetch_or( atomic< T >* obj, T arg ) noexcept {
    return obj->fetch_or( arg );
}

template< typename T >
T atomic_fetch_xor( atomic< T >* obj, T arg ) noexcept {
    return obj->fetch_xor( arg );
}

static inline void atomic_thread_fence( memory_order order ) noexcept {
    __atomic_thread_fence( order );
}

static inline void atomic_signal_fence( memory_order order ) noexcept {
    __atomic_signal_fence( order );
}


class klock {
public:
    explicit klock() = default;
    void acquire() {
        while (flag.test_and_set(std::memory_order_acquire))
            ;
    }
    void release() {
        flag.clear(std::memory_order_release);
    }
    void a() {
        while (flag.test_and_set(std::memory_order_acquire))
            ;
    }
    void r() {
        flag.clear(std::memory_order_release);
    }
private:
    std::atomic_flag flag;
};

class auto_lock {
public:
    explicit auto_lock(klock& lock) : lock_(lock) {
        lock_.acquire();
    }

    ~auto_lock() {
        lock_.release();
    }

private:
    klock& lock_;
};

} // namespace std