#pragma once

#include <util>
#include <new>

namespace std {

    template <typename T>
    class unique_ptr {
    private:
        T* ptr;

    public:
        explicit unique_ptr(T* p = nullptr) : ptr(p) {}
        ~unique_ptr() { delete ptr; }

        unique_ptr(unique_ptr&& other) noexcept : ptr(other.ptr) { other.ptr = nullptr; }
        unique_ptr& operator=(unique_ptr&& other) noexcept {
            if (this != &other) {
                delete ptr;
                ptr = other.ptr;
                other.ptr = nullptr;
            }
            return *this;
        }

        unique_ptr(const unique_ptr&) = delete;
        unique_ptr& operator=(const unique_ptr&) = delete;

        template <typename U>
        unique_ptr(unique_ptr<U>&& other) noexcept : ptr(other.release()) {}

        T& operator*() const { return *ptr; }
        T* operator->() const { return ptr; }
        T* get() const { return ptr; }
        T* release() {
            T* temp = ptr;
            ptr = nullptr;
            return temp;
        }
        void reset(T* p = nullptr) {
            delete ptr;
            ptr = p;
        }
        explicit operator bool() const { return ptr != nullptr; }

        bool operator==(nullptr_t) const { return ptr == nullptr; }
        bool operator!=(nullptr_t) const { return ptr != nullptr; }
        bool operator==(const unique_ptr& other) const { return ptr == other.ptr; }
        bool operator!=(const unique_ptr& other) const { return ptr != other.ptr; }
    };

    template <typename T>
    class shared_ptr {
    private:
        T* ptr;
        size_t* ref_count;

        void release() {
            if (ref_count && --(*ref_count) == 0) {
                delete ptr;
                delete ref_count;
            }
        }

    public:
        explicit shared_ptr(T* p = nullptr) : ptr(p), ref_count(p ? new size_t(1) : nullptr) {}
        shared_ptr(nullptr_t) : ptr(nullptr), ref_count(nullptr) {}
        ~shared_ptr() { release(); }

        shared_ptr(const shared_ptr& other) : ptr(other.ptr), ref_count(other.ref_count) {
            if (ref_count) {
                ++(*ref_count);
            }
        }

        template <typename U>
        shared_ptr(const shared_ptr<U>& other) : ptr(other.get()), ref_count(other.ref_count) {
            if (ref_count) {
                ++(*ref_count);
            }
        }

        shared_ptr& operator=(const shared_ptr& other) {
            if (this != &other) {
                release();
                ptr = other.ptr;
                ref_count = other.ref_count;
                if (ref_count) {
                    ++(*ref_count);
                }
            }
            return *this;
        }

        shared_ptr(shared_ptr&& other) noexcept : ptr(other.ptr), ref_count(other.ref_count) {
            other.ptr = nullptr;
            other.ref_count = nullptr;
        }
        
        shared_ptr& operator=(shared_ptr&& other) noexcept {
            if (this != &other) {
                release();
                ptr = other.ptr;
                ref_count = other.ref_count;
                other.ptr = nullptr;
                other.ref_count = nullptr;
            }
            return *this;
        }

        template<typename U = T>
        typename std::enable_if<!std::is_void<U>::value, U&>::type operator*() const { return *ptr; }

        T* operator->() const { return ptr; }
        T* get() const { return ptr; }
        size_t use_count() const { return ref_count ? *ref_count : 0; }
        explicit operator bool() const { return ptr != nullptr; }

        void reset(T* p = nullptr) {
            release();
            ptr = p;
            ref_count = p ? new size_t(1) : nullptr;
        }

        bool operator==(nullptr_t) const { return ptr == nullptr; }
        bool operator!=(nullptr_t) const { return ptr != nullptr; }
        bool operator==(const shared_ptr& other) const { return ptr == other.ptr; }
        bool operator!=(const shared_ptr& other) const { return ptr != other.ptr; }

        template <typename U>
        friend class shared_ptr;
    };

    template <typename T, typename U>
    std::shared_ptr<T> static_pointer_cast(const std::shared_ptr<U>& sp) noexcept {
        return std::shared_ptr<T>(sp, static_cast<T*>(sp.get()));
    }

    template <typename T, typename U>
    std::shared_ptr<T> dynamic_pointer_cast(const std::shared_ptr<U>& sp) noexcept {
#ifdef __GXX_RTTI
        if (auto p = dynamic_cast<T*>(sp.get())) {
            return std::shared_ptr<T>(sp, p);
        }
        return std::shared_ptr<T>(nullptr);
#else
        (void)sp;
        return std::shared_ptr<T>(nullptr);
#endif
    }

    template <typename T, typename U>
    std::shared_ptr<T> const_pointer_cast(const std::shared_ptr<U>& sp) noexcept {
        return std::shared_ptr<T>(sp, const_cast<U*>(sp.get()));
    }

    template <typename T>
    class allocator {
    public:
        using value_type = T;

        allocator() noexcept = default;
        template <typename U>
        allocator(const allocator<U>&) noexcept {}

        T* allocate(size_t n) {
            if (n > static_cast<size_t>(-1) / sizeof(T)) {
                intr::kpanic(nullptr, "Allocation too large");
            }
            T* ptr = static_cast<T*>(::operator new(n * sizeof(T)));
            if (!ptr) {
                intr::kpanic(nullptr, "Allocation failed");
            }
            return ptr;
        }

        void deallocate(T* ptr, size_t) noexcept {
            ::operator delete(ptr);
        }

        template <typename U, typename... Args>
        void construct(U* ptr, Args&&... args) {
            ::new((void*)ptr) U(std::forward<Args>(args)...);
        }

        template <typename U>
        void destroy(U* ptr) noexcept {
            ptr->~U();
        }

        bool operator==(const allocator&) const noexcept { return true; }
        bool operator!=(const allocator&) const noexcept { return false; }

        template <typename U>
        struct rebind {
            using other = allocator<U>;
        };
    };

    template <typename T>
    struct allocator_traits {
        using allocator_type = T;
        using value_type = typename T::value_type;
        using pointer = value_type*;
        using const_pointer = const value_type*;
        using size_type = size_t;
        using difference_type = ptrdiff_t;

        template <typename U>
        using rebind_alloc = typename T::template rebind<U>::other;

        static pointer allocate(T& alloc, size_type n) {
            return alloc.allocate(n);
        }

        static void deallocate(T& alloc, pointer p, size_type n) {
            alloc.deallocate(p, n);
        }

        template <typename U, typename... Args>
        static void construct(T& alloc, U* p, Args&&... args) {
            alloc.construct(p, std::forward<Args>(args)...);
        }

        template <typename U>
        static void destroy(T& alloc, U* p) {
            alloc.destroy(p);
        }

        static size_type max_size(const T& alloc) noexcept {
            return alloc.max_size();
        }
    };

    template <typename T, typename... Args>
    shared_ptr<T> make_shared(Args&&... args) {
        T* ptr = new T(std::forward<Args>(args)...);
        return shared_ptr<T>(ptr);
    }

    template <typename T>
    unique_ptr<T> make_unique() {
        return unique_ptr<T>(new T());
    }

    template <typename T, typename... Args>
    unique_ptr<T> make_unique(Args&&... args) {
        return unique_ptr<T>(new T(std::forward<Args>(args)...));
    }

} // namespace std
