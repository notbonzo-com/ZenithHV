#pragma once

#include <utility>
#include <new>

namespace std {

    template <typename T, typename Deleter = std::default_delete<T>>
    class unique_ptr {
    private:
        T* ptr;
        Deleter deleter;

    public:
        explicit unique_ptr(T* p = nullptr) noexcept : ptr(p) {}
        ~unique_ptr() { deleter(ptr); }

        unique_ptr(unique_ptr&& other) noexcept : ptr(other.ptr), deleter(std::move(other.deleter)) { other.ptr = nullptr; }
        unique_ptr& operator=(unique_ptr&& other) noexcept {
            if (this != &other) {
                deleter(ptr);
                ptr = other.ptr;
                deleter = std::move(other.deleter);
                other.ptr = nullptr;
            }
            return *this;
        }

        template <typename U, typename E>
        unique_ptr(unique_ptr<U, E>&& other) noexcept : ptr(other.release()), deleter(std::move(other.get_deleter())) {}

        unique_ptr(const unique_ptr&) = delete;
        unique_ptr& operator=(const unique_ptr&) = delete;

        T& operator*() const { return *ptr; }
        T* operator->() const { return ptr; }
        T* get() const { return ptr; }
        T* release() noexcept {
            T* temp = ptr;
            ptr = nullptr;
            return temp;
        }
        void reset(T* p = nullptr) noexcept {
            deleter(ptr);
            ptr = p;
        }
        void swap(unique_ptr& other) noexcept {
            std::swap(ptr, other.ptr);
            std::swap(deleter, other.deleter);
        }

        explicit operator bool() const noexcept { return ptr != nullptr; }

        Deleter& get_deleter() noexcept { return deleter; }
        const Deleter& get_deleter() const noexcept { return deleter; }

        bool operator==(nullptr_t) const noexcept { return ptr == nullptr; }
        bool operator!=(nullptr_t) const noexcept { return ptr != nullptr; }

        T& operator++() { return ++(*ptr); }
        T& operator--() { return --(*ptr); }
        T operator++(int) { return (*ptr)++; }
        T operator--(int) { return (*ptr)--; }
        T operator[](size_t n) const { return ptr[n]; }
        T operator[](size_t n) { return ptr[n]; }
        T operator+(size_t n) const { return ptr + n; }
        T operator+(size_t n) { return ptr + n; }
        T operator-(size_t n) const { return ptr - n; }
        T operator-(size_t n) { return ptr - n; }
    };

    template <typename T, typename Deleter>
    void swap(unique_ptr<T, Deleter>& lhs, unique_ptr<T, Deleter>& rhs) noexcept {
        lhs.swap(rhs);
    }

    template <typename T, typename... Args>
    unique_ptr<T> make_unique(Args&&... args) {
        return unique_ptr<T>(new T(std::forward<Args>(args)...));
    }
}

namespace std {

    template <typename T>
    class shared_ptr {
    private:
        T* ptr;
        std::atomic<size_t>* ref_count;

        void release() noexcept {
            if (ref_count && --(*ref_count) == 0) {
                delete ptr;
                delete ref_count;
            }
        }

    public:
        explicit shared_ptr(T* p = nullptr) 
            : ptr(p), ref_count(p ? new std::atomic<size_t>(1) : nullptr) {}

        shared_ptr(const shared_ptr& other) noexcept 
            : ptr(other.ptr), ref_count(other.ref_count) {
            if (ref_count) {
                ++(*ref_count);
            }
        }

        template <typename U>
        shared_ptr(const shared_ptr<U>& other) noexcept 
            : ptr(other.ptr), ref_count(other.ref_count) {
            if (ref_count) {
                ++(*ref_count);
            }
        }

        shared_ptr(shared_ptr&& other) noexcept 
            : ptr(other.ptr), ref_count(other.ref_count) {
            other.ptr = nullptr;
            other.ref_count = nullptr;
        }

        shared_ptr& operator=(const shared_ptr& other) noexcept {
            if (this != &other) {
                release();
                ptr = other.ptr;
                ref_count = other.ref_count;
                if (ref_count) {
                    ++(*ref_count);
                }
            }
            return *this;
        }

        shared_ptr& operator=(shared_ptr&& other) noexcept {
            if (this != &other) {
                release();
                ptr = other.ptr;
                ref_count = other.ref_count;
                other.ptr = nullptr;
                other.ref_count = nullptr;
            }
            return *this;
        }

        ~shared_ptr() { release(); }

        T& operator*() const { return *ptr; }
        T* operator->() const { return ptr; }
        T* get() const { return ptr; }
        size_t use_count() const noexcept { return ref_count ? *ref_count : 0; }
        explicit operator bool() const noexcept { return ptr != nullptr; }

        void reset(T* p = nullptr) {
            release();
            ptr = p;
            ref_count = p ? new std::atomic<size_t>(1) : nullptr;
        }

        void swap(shared_ptr& other) noexcept {
            std::swap(ptr, other.ptr);
            std::swap(ref_count, other.ref_count);
        }

        bool operator==(const shared_ptr& other) const noexcept { return ptr == other.ptr; }
        bool operator!=(const shared_ptr& other) const noexcept { return ptr != other.ptr; }

        template <typename U>
        friend class shared_ptr;

        T& operator++() { return ++(*ptr); }
        T& operator--() { return --(*ptr); }
        T operator++(int) { return (*ptr)++; }
        T operator--(int) { return (*ptr)--; }
        T operator[](size_t n) const { return ptr[n]; }
        T operator[](size_t n) { return ptr[n]; }
        T operator+(size_t n) const { return ptr + n; }
        T operator+(size_t n) { return ptr + n; }
        T operator-(size_t n) const { return ptr - n; }
        T operator-(size_t n) { return ptr - n; }
    };

    template <typename T>
    void swap(shared_ptr<T>& lhs, shared_ptr<T>& rhs) noexcept {
        lhs.swap(rhs);
    }

    template <typename T, typename... Args>
    shared_ptr<T> make_shared(Args&&... args) {
        return shared_ptr<T>(new T(std::forward<Args>(args)...));
    }

    template <typename T, typename U>
    shared_ptr<T> static_pointer_cast(const shared_ptr<U>& sp) noexcept {
        return shared_ptr<T>(sp, static_cast<T*>(sp.get()));
    }

    template <typename T, typename U>
    shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& sp) noexcept {
        if (auto p = dynamic_cast<T*>(sp.get())) {
            return shared_ptr<T>(sp, p);
        }
        return shared_ptr<T>(nullptr);
    }

    template <typename T, typename U>
    shared_ptr<T> const_pointer_cast(const shared_ptr<U>& sp) noexcept {
        return shared_ptr<T>(sp, const_cast<T*>(sp.get()));
    }

}


namespace std {
    template <typename T>
    class allocator {
    public:
        using value_type = T;

        allocator() noexcept = default;
        template <typename U>
        allocator(const allocator<U>&) noexcept {}

        T* allocate(size_t n) {
            if (n > static_cast<size_t>(-1) / sizeof(T)) {
                intr::kpanic(nullptr, "Allocation too large");
            }
            T* ptr = static_cast<T*>(::operator new(n * sizeof(T)));
            if (!ptr) {
                intr::kpanic(nullptr, "Allocation failed");
            }
            return ptr;
        }

        void deallocate(T* ptr, size_t) noexcept {
            ::operator delete(ptr);
        }

        template <typename U, typename... Args>
        void construct(U* ptr, Args&&... args) {
            ::new((void*)ptr) U(std::forward<Args>(args)...);
        }

        template <typename U>
        void destroy(U* ptr) noexcept {
            ptr->~U();
        }

        bool operator==(const allocator&) const noexcept { return true; }
        bool operator!=(const allocator&) const noexcept { return false; }

        template <typename U>
        struct rebind {
            using other = allocator<U>;
        };
    };

    template <typename T>
    struct allocator_traits {
        using allocator_type = T;
        using value_type = typename T::value_type;
        using pointer = value_type*;
        using const_pointer = const value_type*;
        using size_type = size_t;
        using difference_type = ptrdiff_t;

        template <typename U>
        using rebind_alloc = typename T::template rebind<U>::other;

        static pointer allocate(T& alloc, size_type n) {
            return alloc.allocate(n);
        }

        static void deallocate(T& alloc, pointer p, size_type n) {
            alloc.deallocate(p, n);
        }

        template <typename U, typename... Args>
        static void construct(T& alloc, U* p, Args&&... args) {
            alloc.construct(p, std::forward<Args>(args)...);
        }

        template <typename U>
        static void destroy(T& alloc, U* p) {
            alloc.destroy(p);
        }

        static size_type max_size(const T& alloc) noexcept {
            return alloc.max_size();
        }
    };

    template <typename T, typename... Args>
    shared_ptr<T> make_shared(Args&&... args) {
        T* ptr = new T(std::forward<Args>(args)...);
        return shared_ptr<T>(ptr);
    }

    template <typename T>
    unique_ptr<T> make_unique() {
        return unique_ptr<T>(new T());
    }

    template <typename T, typename... Args>
    unique_ptr<T> make_unique(Args&&... args) {
        return unique_ptr<T>(new T(std::forward<Args>(args)...));
    }

} // namespace std
