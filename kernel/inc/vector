#pragma once

#include <stddef.h>  // for size_t
#include <new>
#include <util>
#include <intr.hpp>

namespace std {

template <typename T>
class vector {
public:
    vector();
    ~vector() noexcept;
    vector(const vector& other);
    vector& operator=(const vector& other);

    void push_back(const T& value);
    void pop_back();
    T& operator[](size_t index);
    const T& operator[](size_t index) const;
    size_t size() const noexcept;
    size_t capacity() const noexcept;

private:
    T* data;
    size_t _size;
    size_t _capacity;

    void resize(size_t new_capacity);
    void destroy_elements() noexcept;
};

template <typename T>
vector<T>::vector() : data(nullptr), _size(0), _capacity(0) {}

template <typename T>
vector<T>::~vector() noexcept {
    destroy_elements();
    if (data) {
        kfree(data);
    }
}

template <typename T>
vector<T>::vector(const vector& other) : data(nullptr), _size(0), _capacity(0) {
    if (other._size > 0) {
        data = static_cast<T*>(kmalloc(other._capacity * sizeof(T)));
        if (!data) {
            intr::kpanic(nullptr, "bad_alloc()");
        }
        for (size_t i = 0; i < other._size; ++i) {
            new (&data[i]) T(other.data[i]);  // Copy construct elements
        }
        _size = other._size;
        _capacity = other._capacity;
    }
}

template <typename T>
vector<T>& vector<T>::operator=(const vector& other) {
    if (this != &other) {
        destroy_elements();
        if (data) {
            kfree(data);
        }

        data = nullptr;
        _size = 0;
        _capacity = 0;

        if (other._size > 0) {
            data = static_cast<T*>(kmalloc(other._capacity * sizeof(T)));
            if (!data) {
                intr::kpanic(nullptr, "bad_alloc()");
            }
            for (size_t i = 0; i < other._size; ++i) {
                new (&data[i]) T(other.data[i]);  // Copy construct elements
            }
            _size = other._size;
            _capacity = other._capacity;
        }
    }
    return *this;
}

template <typename T>
void vector<T>::push_back(const T& value) {
    if (_size == _capacity) {
        resize(_capacity == 0 ? 1 : _capacity * 2);
    }
    new (&data[_size]) T(value);  // Placement new to construct object
    ++_size;
}

template <typename T>
void vector<T>::pop_back() {
    if (_size == 0) {
        intr::kpanic(nullptr, "pop_back() called on empty vector");
    }
    data[--_size].~T();
}

template <typename T>
T& vector<T>::operator[](size_t index) {
    if (index >= _size) {
        intr::kpanic(nullptr, "index out of range");
    }
    return data[index];
}

template <typename T>
const T& vector<T>::operator[](size_t index) const {
    if (index >= _size) {
        intr::kpanic(nullptr, "index out of range");
    }
    return data[index];
}

template <typename T>
size_t vector<T>::size() const noexcept {
    return _size;
}

template <typename T>
size_t vector<T>::capacity() const noexcept {
    return _capacity;
}

template <typename T>
void vector<T>::resize(size_t new_capacity) {
    T* new_data = static_cast<T*>(kmalloc(new_capacity * sizeof(T)));
    if (!new_data) {
        intr::kpanic(nullptr, "bad_alloc()");
    }
    for (size_t i = 0; i < _size; ++i) {
        new (&new_data[i]) T(std::move(data[i]));  // Move old objects to new location
    }
    destroy_elements();  // Destroy old elements
    if (data) {
        kfree(data);  // Free old memory
    }
    data = new_data;
    _capacity = new_capacity;
}

template <typename T>
void vector<T>::destroy_elements() noexcept {
    for (size_t i = 0; i < _size; ++i) {
        data[i].~T();
    }
    _size = 0;  // Reset size
}


}
