#pragma once

#include <utility>
#include <new>
#include <atomic>
#include <allocator>

namespace std {

    template <typename T, typename Deleter = std::default_delete<T>>
    class unique_ptr {
    private:
        T* ptr;
        Deleter deleter;

    public:
        explicit unique_ptr(T* p = nullptr) noexcept : ptr(p) {}
        ~unique_ptr() { deleter(ptr); }

        unique_ptr(unique_ptr&& other) noexcept : ptr(other.ptr), deleter(std::move(other.deleter)) { other.ptr = nullptr; }
        unique_ptr& operator=(unique_ptr&& other) noexcept {
            if (this != &other) {
                deleter(ptr);
                ptr = other.ptr;
                deleter = std::move(other.deleter);
                other.ptr = nullptr;
            }
            return *this;
        }

        template <typename U, typename E>
        unique_ptr(unique_ptr<U, E>&& other) noexcept : ptr(other.release()), deleter(std::move(other.get_deleter())) {}

        unique_ptr(const unique_ptr&) = delete;
        unique_ptr& operator=(const unique_ptr&) = delete;

        T& operator*() const { return *ptr; }
        T* operator->() const { return ptr; }
        T* get() const { return ptr; }
        T* release() noexcept {
            T* temp = ptr;
            ptr = nullptr;
            return temp;
        }
        void reset(T* p = nullptr) noexcept {
            deleter(ptr);
            ptr = p;
        }
        void swap(unique_ptr& other) noexcept {
            std::swap(ptr, other.ptr);
            std::swap(deleter, other.deleter);
        }

        explicit operator bool() const noexcept { return ptr != nullptr; }

        Deleter& get_deleter() noexcept { return deleter; }
        const Deleter& get_deleter() const noexcept { return deleter; }

        bool operator==(nullptr_t) const noexcept { return ptr == nullptr; }
        bool operator!=(nullptr_t) const noexcept { return ptr != nullptr; }

        T& operator++(int) { return (*ptr)++; }
        T& operator--(int) { return (*ptr)--; }
        T& operator[](size_t n) { return ptr[n]; }
        const T& operator[](size_t n) const { return ptr[n]; }
        T* operator+(size_t n) const { return ptr + n; }
        T* operator+(size_t n) { return ptr + n; }
        T* operator-(size_t n) const { return ptr - n; }
        T* operator-(size_t n) { return ptr - n; }

    };

    template <typename T, typename Deleter>
    void swap(unique_ptr<T, Deleter>& lhs, unique_ptr<T, Deleter>& rhs) noexcept {
        lhs.swap(rhs);
    }

    template <typename T>
    class shared_ptr {
    private:
        T* ptr;
        std::atomic<size_t>* ref_count;

        void release() noexcept {
            if (ref_count && --(*ref_count) == 0) {
                delete ptr;
                delete ref_count;
            }
        }

    public:
        explicit shared_ptr(T* p = nullptr) 
            : ptr(p), ref_count(p ? new std::atomic<size_t>(1) : nullptr) {}
        
        shared_ptr(nullptr_t) noexcept
            : ptr(nullptr), ref_count(nullptr) {}

        shared_ptr(const shared_ptr& other) noexcept 
            : ptr(other.ptr), ref_count(other.ref_count) {
            if (ref_count) {
                ++(*ref_count);
            }
        }

        template <typename U>
        shared_ptr(const shared_ptr<U>& other, T* p) noexcept
            : ptr(p), ref_count(other.ref_count) {
            if (ref_count) {
                ++(*ref_count);
            }
        }

        template <typename U>
        shared_ptr(const shared_ptr<U>& other) noexcept 
            : ptr(other.ptr), ref_count(other.ref_count) {
            if (ref_count) {
                ++(*ref_count);
            }
        }

        shared_ptr(shared_ptr&& other) noexcept 
            : ptr(other.ptr), ref_count(other.ref_count) {
            other.ptr = nullptr;
            other.ref_count = nullptr;
        }

        shared_ptr& operator=(const shared_ptr& other) noexcept {
            if (this != &other) {
                release();
                ptr = other.ptr;
                ref_count = other.ref_count;
                if (ref_count) {
                    ++(*ref_count);
                }
            }
            return *this;
        }

        shared_ptr& operator=(shared_ptr&& other) noexcept {
            if (this != &other) {
                release();
                ptr = other.ptr;
                ref_count = other.ref_count;
                other.ptr = nullptr;
                other.ref_count = nullptr;
            }
            return *this;
        }

        ~shared_ptr() { release(); }

        T& operator*() const { return *ptr; }
        T* operator->() const { return ptr; }
        T* get() const { return ptr; }
        size_t use_count() const noexcept { return ref_count ? ref_count->load() : 0; }
        explicit operator bool() const noexcept { return ptr != nullptr; }

        void reset(T* p = nullptr) {
            release();
            ptr = p;
            ref_count = p ? new std::atomic<size_t>(1) : nullptr;
        }

        void swap(shared_ptr& other) noexcept {
            std::swap(ptr, other.ptr);
            std::swap(ref_count, other.ref_count);
        }

        bool operator==(const shared_ptr& other) const noexcept { return ptr == other.ptr; }
        bool operator!=(const shared_ptr& other) const noexcept { return ptr != other.ptr; }

        template <typename U>
        friend class shared_ptr;

        T& operator++() { return ++(*ptr); }
        T& operator--() { return --(*ptr); }
        T operator++(int) { return (*ptr)++; }
        T operator--(int) { return (*ptr)--; }
        T operator[](size_t n) const { return ptr[n]; }
        T operator[](size_t n) { return ptr[n]; }
        T operator+(size_t n) const { return ptr + n; }
        T operator+(size_t n) { return ptr + n; }
        T operator-(size_t n) const { return ptr - n; }
        T operator-(size_t n) { return ptr - n; }
    };

    template <typename T>
    void swap(shared_ptr<T>& lhs, shared_ptr<T>& rhs) noexcept {
        lhs.swap(rhs);
    }

    template <typename T, typename U>
    std::shared_ptr<T> static_pointer_cast(const std::shared_ptr<U>& sp) noexcept {
        return std::shared_ptr<T>(sp, static_cast<T*>(sp.get()));
    }


    template <typename T, typename U>
    shared_ptr<T> const_pointer_cast(const shared_ptr<U>& sp) noexcept {
        return shared_ptr<T>(sp, const_cast<T*>(sp.get()));
    }

        template <typename T, typename... Args>
    shared_ptr<T> make_shared(Args&&... args) {
        T* ptr = new T(std::forward<Args>(args)...);
        return shared_ptr<T>(ptr);
    }

    template <typename T>
    unique_ptr<T> make_unique() {
        return unique_ptr<T>(new T());
    }

    template <typename T, typename... Args>
    unique_ptr<T> make_unique(Args&&... args) {
        return unique_ptr<T>(new T(std::forward<Args>(args)...));
    }

} // namespace std
